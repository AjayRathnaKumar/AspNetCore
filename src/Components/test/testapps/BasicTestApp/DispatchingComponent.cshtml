@using System.Timers

<h1>Dispatching</h1>

<p>
    Sometimes, renders need to be triggered in response to non-lifecyle events.
    The current thread will not be associated with the renderer's sync context,
    so the render request has to be marshalled onto that sync context.
</p>

<p>
    Result: <strong id="result">@result</strong>
</p>

<button id="run-without-dispatch" onclick=@RunWithoutDispatch>Run without dispatch</button>
<button id="run-with-dispatch" onclick=@RunWithDispatch>Run with dispatch</button>
<button id="run-with-double-dispatch" onclick=@RunWithDoubleDispatch>Run with double dispatch</button>

@functions {
    string result;

    async Task RunWithoutDispatch()
    {
        await Task.Delay(1).ConfigureAwait(false);
        AttemptToRender();
    }

    async Task RunWithDispatch()
    {
        await Task.Delay(1).ConfigureAwait(false);
        Dispatch(AttemptToRender);

        // So we can observe that the dispatched work item ran synchronously
        if (result == "Success")
        {
            result += " (completed synchronously)";
        }
    }

    async Task RunWithDoubleDispatch()
    {
        await Task.Delay(1).ConfigureAwait(false);
        Dispatch(() => Dispatch(AttemptToRender));

        // So we can observe that the dispatched work item ran synchronously
        if (result == "Success")
        {
            result += " (completed synchronously)";
        }
    }

    void AttemptToRender()
    {
        try
        {
            result = "Success";
            StateHasChanged();
        }
        catch (Exception ex)
        {
            result = ex.ToString();
        }
    }
}
